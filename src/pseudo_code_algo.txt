-----------------------------------------------
ALgo Step 1: send IPv6 packet 
-----------------------------------------------

Implements: 
    LowpanAPI instance Lowpanapi

Uses: 
    LowpanCore instance lowpanCore;
    Routingtable instance routingtable 



upon event <lowpanapi, Send_pckt | IPv6Pckt> do 
    PcktInfo := lowpan_core:get_pckt_info
    SrcAddress := PcktInfo:get_source_address
    DstAddress :=  PcktInfo:get_dest_address

    if SrcAddress in MulticatAddress then 
        return error_multicast_src
    else if DstAddress in Unspecified then 
        return error_unspecified_addr
    else 
        trigger <lowpanapi, pckt_tx |
                {Ipv6Pckt, PcktInfo, Extended_hopsleft, self()}
                >
    wait_to_receive Response 
    upon event <receive | Response>
        return Response


-----------------------------------------------
ALgo Step 2: Transmit IPv6 packet 
-----------------------------------------------
Implements: 
    LowpanAPI instance Lowpanapi

Uses: 
    LowpanCore instance lowpanCore;
    Routingtable instance routingtable 

upon event <lowpanapi, tx_packet | {Ipv6Pckt, PcktInfo, Extended_hopsleft, From}>
    PcktInfo := lowpan_core:get_pckt_info
    SrcAddress := PcktInfo:get_source_address
    DstAddress :=  PcktInfo:get_dest_address
    Payload := PcktInfo:get_payload
    DestMacAddress := lowpancore:get_Src_EUI64_mac_addr
    SenderMacAdd := lowpancore:get_DstEUI64_mac_addr
    {RouteExist, MeshedHdrBin, MH} := lowpancore:get_next_hop
    CompressedHeader := lowpancore:compress_ipv6_header
    CompressedPacket := build_packet 
    {FragReq, Fragments} = lowpan_core:trigger_fragmentation
    
    if FraqReq is true then 
        send_fragments(..)
        trigger <lowpanapi, reply| Response>
    
    else if FraqReq is false then 
        send_fragment(..)
        trigger <lowpanapi, reply| Response>
    
    else if FraqReq is size_err then 
        trigger <lowpanapi, reply| error_frag_size>

        
-----------------------------------------------
ALgo Step 1: Frame reception 
-----------------------------------------------
upon event <InputCallback, new_frame | Frame>
    CurrNodeMacAdd <- getCurrentNodeAddr
    {FC, MH, Datagram} = Frame,
    {IsMeshedPckt, FinalDstMacAdd, MeshPckInfo} = lowpan_core:contains_mesh_header(Datagram)
    {OriginatorMacAddr, FinalDstMacAdd} <- MeshPckInfo

    if FinalDstMacAdd in CurrNodeMacAdd then
        if IsMeshedPckt in true then 
            Rest <- lowpan_core:remove_mesh_header
            trigger <lowpanapi, new_frame_rx | IsMeshedPckt, OriginatorAddr, Rest>
        
        else if IsMeshedPckt in false then 
            HopsLeft := 1
            Rest <- lowpan_core:remove_mesh_header
            trigger <lowpanapi, new_frame_rx | IsMeshedPckt, OriginatorAddr, Rest>

    else if  FinalDstMacAdd in BroadcastAdd then 
        trigger <lowpanapi, keepstate>

    else
        trigger<lowpanapi, forward | Frame, IsMeshedPckt, OriginatorAddr, FinalDstMacAdd, CurrNodeMacAdd>


-----------------------------------------------
ALgo Step 2: Frame reception 
-----------------------------------------------

upon event <new_frame_rx | IsMeshedPckt, OriginatorAddr, Datagram, From>
    if Datagram in not fragmented then 
        if Datagram in (Compressed or UnCompressed) then
            reply reassembled_packet to From 
        
    if in fragmented then
        trigger<lowpanapi, start_collect |  IsMeshedPckt, OriginatorAddr, Datagram>
    



-----------------------------------------------
ALgo Step 4: Add new datagram
-----------------------------------------------

upon event <start_collect | Frame, IsMeshedPckt, OriginatorAddr, FinalDstMacAdd, CurrNodeMacAdd, From>
    storingResult <- lowpancore:storeFragment 

    if storingResult in complete_first_frag then 
        reply reassembled_packet to From
    
    else if storingResult in complete then 
         reply reassembled_packet to From
    
    else storingResult in (duplicate or incomplete or incomplete_first) then 
        trigger<lowpanapi, start_reassemble | IsMeshedPckt, OriginatorAddr, Key, UpdatedDatagram, From>
    



-----------------------------------------------
ALgo Step 5: Reassemble
-----------------------------------------------

upon event <start_reassemble | IsMeshedPckt, OriginatorAddr, Key, UpdatedDatagram, From>
    ReassembledPacket <- lowpan_core:reassemble
    delete_entry(DatagramMap, EntryKey)
    reply reassembled_packet to From

-----------------------------------------------
ALgo Step 6: Forward
-----------------------------------------------

trigger<lowpanapi, start_forward | Frame, IsMeshedPckt, OriginatorAddr, FinalDstMacAdd, CurrNodeMacAdd, From>
    if IsMeshedPckt in true then 
        {Is_Extended_hopsleft, HopLft} <- getHopLeft
        if  HopLft == 0 then 
            reply discard to From 

        else 
            NewMeshHeader := updateMeshHeader 
            BinMeshHeader := lowpan_core:build_mesh_header
            NewDatagram := createNewDatagram

    else
        BinMeshHeader := lowpan_core:create_new_mesh_datagram
        NewDatagram := createNewDatagram

    if NewDatagram in discard then 
        don't transit 
    else 
        NextHopAddr := routing_table:get_route
        ieee802154:transmission(NewDatagram)